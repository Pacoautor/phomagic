def generate_photo(request, subcategory_id, view_id):
    subcategory = get_object_or_404(Subcategory, id=subcategory_id)
    viewopt = get_object_or_404(ViewOption, id=view_id, subcategory_id=subcategory_id)
    
    # Prompts preferentemente filtrados por vista; si no hay, por subcategoría sin vista
    prompts = MasterPrompt.objects.filter(subcategory_id=subcategory_id, view_id=view_id)
    if not prompts.exists():
        prompts = MasterPrompt.objects.filter(subcategory_id=subcategory_id, view__isnull=True)

    # Miniaturas de referencia (si existen)
    prompt_previews = {}
    for p in prompts:
        try:
            prompt_previews[p.id] = p.reference_photo.url if getattr(p, "reference_photo", None) else ""
        except Exception:
            prompt_previews[p.id] = ""

    # Lógica de generación y renderizado
    if request.method == "POST":
        product_photo_file = request.FILES.get("product_photo")
        master_prompt_id = request.POST.get("master_prompt")
        
        urls = {}
        error_msg = None
        final_prompt = ""

        if product_photo_file and master_prompt_id:
            try:
                mp = get_object_or_404(MasterPrompt, id=master_prompt_id)
                final_prompt = f"{mp.prompt_text}"
                
                # Generación de la imagen
                # La función _openai_image_edit_via_rest necesita el prompt y el archivo de imagen.
                # Asegúrate de que tu modelo OpenAI sea el correcto y esté configurado para image_edits
                # como lo muestra el código de ejemplo.
                image_bytes = _openai_image_edit_via_rest(final_prompt, product_photo_file, "1024x1024")
                
                # Guardado y escalado
                urls = _save_and_optionally_downscale(
                    image_bytes, f"result_{subcategory_id}_{view_id}", "1024x1024"
                )
                
            except requests.HTTPError as http_err:
                error_msg = f"Error HTTP de OpenAI: {http_err.response.status_code} – {http_err.response.text}"
            except Exception as e:
                error_msg = f"¡Ha ocurrido un error en la API de OpenAI! Error: {e}"

        # Lógica de verificación y renderizado
        # Alias para el template, se usan en el result.html
        safe_urls = {
            "image_1024": urls.get("1024x1024"),
            "image_512": urls.get("512x512"),
            "image_256": urls.get("256x256"),
        }

        # Si hubo un error en la generación y no tenemos URLs, ponemos un mensaje genérico.
        if not safe_urls["image_1024"] and not error_msg:
            error_msg = (
                "No se generó ninguna imagen. Si estás usando OpenAI, "
                "revisa el saldo/limite de facturación y los logs del servicio."
            )
        
        # Si tienes error_msg, sobrescribe las URLs a None para evitar mostrar URLs inválidas.
        if error_msg:
            safe_urls = {
                "image_1024": None,
                "image_512": None,
                "image_256": None,
            }

        return render(
            request,
            "products/result.html",
            {
                "subcategory": subcategory,
                "viewopt": viewopt,
                "prompt": final_prompt,
                "image_1024": safe_urls["image_1024"],
                "image_512": safe_urls["image_512"],
                "image_256": safe_urls["image_256"],
                "error_msg": error_msg,
            },
        )
    
    # Renderizado del formulario inicial si es un GET
    return render(
        request,
        "products/generate_photo.html",
        {"subcategory": subcategory, "viewopt": viewopt, "prompts": prompts, "prompt_previews": prompt_previews},
    )